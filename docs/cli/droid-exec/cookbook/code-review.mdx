---
title: Automated Code Review
description: Automate pull request reviews using Droid Exec in GitHub Actions
---

This tutorial shows you how to set up automated code review using Droid Exec in GitHub Actions. The workflow will analyze pull requests, identify issues, and post feedback as inline comments.

<Info>
Unlike interactive CLI sessions, Droid Exec runs in headless mode, making it perfect for CI/CD automation. The agent analyzes code changes, identifies issues, and creates structured output that can be posted as PR comments.
</Info>

## How it works

The workflow:

1.  Triggers on pull request events
2.  Fetches existing bot comments to avoid duplicates
3.  Generates a diff and uses Droid Exec to analyze changes
4.  Posts inline comments on specific lines with issues
5.  Falls back to issue comments if inline review fails

<div style={{ display: 'flex', gap: '1rem', flexWrap: 'wrap' }}>
  <div style={{ flex: '1', minWidth: '300px' }}>
    <img src="./code-review-picture-1.png" alt="Droid Exec posting inline comments on PR with detected issues" />
  </div>
  <div style={{ flex: '1', minWidth: '300px' }}>
    <img src="./code-review-picture-2.png" alt="Droid Exec approval comment on clean PR" />
  </div>
</div>

<Accordion title="Full Workflow File">
````yaml
name: Droid PR Review
on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

concurrency:
  group: droid-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  review:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      pull-requests: write
      issues: write
    if: github.event.pull_request.draft == false

    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup droid CLI
        run: |
          curl -fsSL https://app.factory.ai/cli | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          $HOME/.local/bin/droid --version

      - name: Fetch existing bot comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const pull_number = context.issue.number;

            const comments = await github.paginate(github.rest.pulls.listReviewComments, {
              owner,
              repo,
              pull_number,
            });

            const botComments = comments.filter((comment) => {
              const user = comment.user;
              if (!user) return false;
              return user.type === 'Bot' || (user.login && user.login.includes('github-actions'));
            });

            fs.writeFileSync('existing_comments.json', JSON.stringify(botComments, null, 2));

      - name: Generate and analyze diff
        env:
          FACTORY_API_KEY: ${{ secrets.FACTORY_API_KEY }}
        run: |
          set -euo pipefail

          git fetch origin ${{ github.event.pull_request.base.ref }}
          git diff origin/${{ github.event.pull_request.base.ref }}...HEAD > pr.diff

          cat > prompt.txt <<'EOF'
          Review the PR diff and identify only critical issues that need fixing.

          FOCUS ON:
          - Dead/unreachable code (if false, code after return)
          - Broken control flow (missing break, infinite loops)
          - Async/await mistakes (missing await, unhandled promises)
          - React hook dependency issues
          - Type safety issues (wrong operators, null derefs)
          - Security vulnerabilities (SQL injection, XSS)
          - Clear bugs that will cause runtime errors

          SKIP:
          - Style, formatting, naming conventions
          - Minor optimizations
          - Architecture or design patterns
          - Test coverage suggestions
          - Already reported issues in existing_comments.json

          Output a JSON array of inline comments:
          [
            {
              "path": "file/path.js",
              "line": 42,
              "body": "Issue: [description]\\nFix: [specific solution]"
            }
          ]

          Use GitHub review ‚Äúposition‚Äù (not file line). Compute positions from pr.diff. If no critical issues, output []
          Files to review:
          - pr.diff: the full PR diff
          - existing_comments.json: skip exact duplicates
          EOF

          # Append artifacts so Droid sees actual diff and prior comments
          {
            printf "\n--- BEGIN pr.diff ---\n";
            cat pr.diff;
            printf "\n--- END pr.diff ---\n";
            printf "\n--- BEGIN existing_comments.json ---\n";
            cat existing_comments.json || true;
            printf "\n--- END existing_comments.json ---\n";
          } >> prompt.txt

          if ! droid exec --auto medium --model gpt-5-codex --output-format json -f prompt.txt > comments.json 2>review_output.log; then
            echo "droid exec failed"
            cat review_output.log
            exit 1
          fi

          if ! python3 -m json.tool < comments.json > /dev/null 2>&1; then
            echo "Invalid JSON in comments.json, defaulting to empty array"
            cp comments.json review_output.log || true
            echo "[]" > comments.json
          fi

      - name: Post review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const { owner, repo } = context.repo;
            const pull_number = context.issue.number;
            const headSha = context.payload.pull_request.head.sha;
            const commentsPath = 'comments.json';

            const readComments = () => {
              if (!fs.existsSync(commentsPath)) {
                core.info('No comments file found.');
                return [];
              }

              try {
                const data = JSON.parse(fs.readFileSync(commentsPath, 'utf8'));
                return Array.isArray(data) ? data : [];
              } catch (error) {
                core.warning(`Failed to parse comments.json: ${error.message}`);
                return [];
              }
            };

            const postBatchReview = async (body, comments = []) => {
              const payload = { owner, repo, pull_number, event: 'COMMENT', body };
              if (comments.length) payload.comments = comments; // needs path+position+body
              await github.rest.pulls.createReview(payload);
            };

            const postPerComment = async (comments) => {
              for (const c of comments) {
                // expects: path, line (new file), side ("RIGHT"), body
                await github.rest.pulls.createReviewComment({
                  owner,
                  repo,
                  pull_number,
                  commit_id: headSha,
                  path: c.path,
                  line: c.line,
                  side: c.side || 'RIGHT',
                  body: c.body,
                });
              }
            };

            const postIssueSummary = async (comments) => {
              const body = comments
                .map((c) => {
                  const loc = c.position != null ? `${c.path}:${c.position}` :
                             c.line != null ? `${c.path}:${c.line}` : c.path;
                  return `**${loc}**\n${c.body}`;
                })
                .join('\n\n---\n\n');

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pull_number,
                body: `üîç Automated review found issues:\n\n${body}`,
              });
            };

            const comments = readComments();

            if (!comments.length) {
              await postBatchReview('‚úÖ Automated review complete - no critical issues found.');
              return;
            }

            const hasOnlyPositions = comments.every(c => Number.isInteger(c.position));
            const hasAnyLine = comments.some(c => Number.isInteger(c.line));

            try {
              if (hasOnlyPositions) {
                await postBatchReview(`üîç Automated review found ${comments.length} issue(s) requiring attention.`, comments);
                core.info(`Posted ${comments.length} review comment(s) via batch (position).`);
              } else if (hasAnyLine) {
                await postPerComment(comments);
                // Optional: add a summary review comment
                await postBatchReview(`üîç Automated review posted ${comments.length} inline comment(s).`);
                core.info(`Posted ${comments.length} review comment(s) individually (line/side).`);
              } else {
                core.warning('Comments lack required fields (position or line). Falling back to issue comment.');
                await postIssueSummary(comments);
              }
            } catch (error) {
              core.warning(`Failed to post inline review: ${error.message}`);
              try {
                await postIssueSummary(comments);
              } catch (fallbackError) {
                core.setFailed(`Unable to post review: ${fallbackError.message}`);
              }
            }

      - name: Upload artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: review-debug-${{ github.event.pull_request.number }}
          path: |
            pr.diff
            prompt.txt
            review_output.log
            comments.json
            existing_comments.json
          if-no-files-found: ignore
          retention-days: 7
````
</Accordion>

## Prerequisites

<Steps>
  <Step title="GitHub Repository">
    Ensure you have a GitHub repository with Actions enabled
  </Step>
  
  <Step title="Get Factory API Key">
    Generate your API key from the [Factory Settings Page](https://app.factory.ai/settings/api-keys)
  </Step>
  
  <Step title="GitHub Actions Knowledge">
    Basic understanding of GitHub Actions workflows
  </Step>
</Steps>

## Configure authentication

Add your Factory API key as a repository secret:

1.  Go to your repository's Settings ‚Üí Secrets and variables ‚Üí Actions
2.  Click "New repository secret"
3.  Name: `FACTORY_API_KEY`
4.  Value: Your Factory API key (starts with `fk-`)

## Build the GitHub Actions workflow

Let's build the workflow step by step to understand each component.

### Set up the workflow trigger

Create `.github/workflows/droid-code-review.yml` and configure when it should run:

```yaml
name: Droid PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

concurrency:
  group: droid-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true
```

The `concurrency` group ensures only one review runs per PR at a time, canceling outdated runs when new commits are pushed.

### Configure job permissions

Set up the job with necessary permissions and conditions:

```yaml
jobs:
  review:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Reduced timeout for faster feedback
    
    permissions:
      contents: read       # Read repository contents
      pull-requests: write # Post PR comments
      issues: write        # Fallback comment posting
    
    # Skip draft PRs to avoid noise during development
    if: github.event.pull_request.draft == false

```

### Checkout the repository

Add the checkout step to access the PR code:

```yaml
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for accurate diffs
          ref: ${{ github.event.pull_request.head.sha }}
```

### Install Droid CLI

Install the Factory Droid CLI in the runner:

```yaml
      - name: Setup droid CLI
        run: |
          curl -fsSL https://app.factory.ai/cli | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          $HOME/.local/bin/droid --version
```

### Fetch existing bot comments

Before running the review, fetch existing bot comments to avoid duplicates:

```yaml
      - name: Fetch existing bot comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const pull_number = context.issue.number;

            const comments = await github.paginate(github.rest.pulls.listReviewComments, {
              owner,
              repo,
              pull_number,
            });

            const botComments = comments.filter((comment) => {
              const user = comment.user;
              if (!user) return false;
              return user.type === 'Bot' || (user.login && user.login.includes('github-actions'));
            });

            fs.writeFileSync('existing_comments.json', JSON.stringify(botComments, null, 2));
```

### Generate and analyze diff

Now let's create the review step. The prompt defines what issues to look for and how to format comments:

````yaml
      - name: Generate and analyze diff
        env:
          FACTORY_API_KEY: ${{ secrets.FACTORY_API_KEY }}
        run: |
          set -euo pipefail

          git fetch origin ${{ github.event.pull_request.base.ref }}
          git diff origin/${{ github.event.pull_request.base.ref }}...HEAD > pr.diff

          cat > prompt.txt <<'EOF'
          Review the PR diff and identify only critical issues that need fixing.

          FOCUS ON:
          - Dead/unreachable code (if false, code after return)
          - Broken control flow (missing break, infinite loops)
          - Async/await mistakes (missing await, unhandled promises)
          - React hook dependency issues
          - Type safety issues (wrong operators, null derefs)
          - Security vulnerabilities (SQL injection, XSS)
          - Clear bugs that will cause runtime errors

          SKIP:
          - Style, formatting, naming conventions
          - Minor optimizations
          - Architecture or design patterns
          - Test coverage suggestions
          - Already reported issues in existing_comments.json

          Output a JSON array of inline comments:
          [
            {
              "path": "file/path.js",
              "line": 42,
              "side": "RIGHT",
              "body": "Issue: [description]\nFix: [specific solution]"
            }
          ]

          If no critical issues found, output empty array: []

          Files to review:
          - pr.diff: the full PR diff
          - existing_comments.json: skip exact duplicates
          EOF

          if ! droid exec --auto medium --model gpt-5-codex --output-format json -f prompt.txt > comments.json 2>review_output.log; then
            echo "droid exec failed"
            cat review_output.log
            exit 1
          fi

          if ! python3 -m json.tool < comments.json > /dev/null 2>&1; then
            echo "Invalid JSON in comments.json, defaulting to empty array"
            cp comments.json review_output.log || true
            echo "[]" > comments.json
          fi
````

### Post the review

Post the generated comments as a PR review with inline comments or fallback to issue comments:

```yaml
      - name: Post review
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            const { owner, repo } = context.repo;
            const pull_number = context.issue.number;
            const headSha = context.payload.pull_request.head.sha;
            const commentsPath = 'comments.json';

            const readComments = () => {
              if (!fs.existsSync(commentsPath)) {
                core.info('No comments file found.');
                return [];
              }

              try {
                const data = JSON.parse(fs.readFileSync(commentsPath, 'utf8'));
                return Array.isArray(data) ? data : [];
              } catch (error) {
                core.warning(`Failed to parse comments.json: ${error.message}`);
                return [];
              }
            };

            const postBatchReview = async (body, comments = []) => {
              const payload = { owner, repo, pull_number, event: 'COMMENT', body };
              if (comments.length) payload.comments = comments; // needs path+position+body
              await github.rest.pulls.createReview(payload);
            };

            const postPerComment = async (comments) => {
              for (const c of comments) {
                // expects: path, line (new file), side ("RIGHT"), body
                await github.rest.pulls.createReviewComment({
                  owner,
                  repo,
                  pull_number,
                  commit_id: headSha,
                  path: c.path,
                  line: c.line,
                  side: c.side || 'RIGHT',
                  body: c.body,
                });
              }
            };

            const postIssueSummary = async (comments) => {
              const body = comments
                .map((c) => {
                  const loc = c.position != null ? `${c.path}:${c.position}` :
                             c.line != null ? `${c.path}:${c.line}` : c.path;
                  return `**${loc}**\n${c.body}`;
                })
                .join('\n\n---\n\n');

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pull_number,
                body: `üîç Automated review found issues:\n\n${body}`,
              });
            };

            const comments = readComments();

            if (!comments.length) {
              await postBatchReview('‚úÖ Automated review complete - no critical issues found.');
              return;
            }

            const hasOnlyPositions = comments.every(c => Number.isInteger(c.position));
            const hasAnyLine = comments.some(c => Number.isInteger(c.line));

            try {
              if (hasOnlyPositions) {
                await postBatchReview(`üîç Automated review found ${comments.length} issue(s) requiring attention.`, comments);
                core.info(`Posted ${comments.length} review comment(s) via batch (position).`);
              } else if (hasAnyLine) {
                await postPerComment(comments);
                // Optional: add a summary review comment
                await postBatchReview(`üîç Automated review posted ${comments.length} inline comment(s).`);
                core.info(`Posted ${comments.length} review comment(s) individually (line/side).`);
              } else {
                core.warning('Comments lack required fields (position or line). Falling back to issue comment.');
                await postIssueSummary(comments);
              }
            } catch (error) {
              core.warning(`Failed to post inline review: ${error.message}`);
              try {
                await postIssueSummary(comments);
              } catch (fallbackError) {
                core.setFailed(`Unable to post review: ${fallbackError.message}`);
              }
            }
```

### Save artifacts on failure

Store review artifacts for troubleshooting if the workflow fails:

```yaml
      - name: Upload artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: review-debug-${{ github.event.pull_request.number }}
          path: |
            pr.diff
            prompt.txt
            review_output.log
            comments.json
            existing_comments.json
          if-no-files-found: ignore
          retention-days: 7
```


## Test your reviewer

Create a test PR with some intentional issues to verify the workflow:

```javascript
// Example code with issues
function processData(data) {
  if (false) {  // Dead code
    console.log("This never runs");
  }
  
  data.forEach(async item => {  // Missing await
    processItem(item);
  });
  
  if (data = null) {  // Changed assignment to comparison
    return;
  }
}
```

The reviewer should identify these issues and post inline comments.

---
title: "Mass Import Refactoring"
description: "Automatically organize and optimize imports across your entire codebase using parallel AI-powered refactoring"
---

This tutorial demonstrates how to use Droid Exec to refactor import statements across hundreds of files simultaneously. The script intelligently groups, sorts, and optimizes imports while removing unused dependencies and converting module formats.

## How it works

The script:

1. Scans your codebase for JavaScript/TypeScript files
2. Analyzes each file's import structure and usage
3. Groups imports by type (external, internal, relative)
4. Removes genuinely unused imports
5. Converts CommonJS to ES6 modules where appropriate
6. Applies consistent formatting and style


## Real-world impact

<CardGroup cols={2}>
  <Card title="Files Processed" icon="files">
    Process hundreds of files in parallel
  </Card>
  <Card title="Unused Removed" icon="trash">
    Automatically eliminate unused imports
  </Card>
</CardGroup>

## Prerequisites

<Steps>
  <Step title="Install Droid CLI">
    ```bash
    curl -fsSL https://app.factory.ai/cli | sh
    ```
  </Step>
  
  <Step title="Get Factory API Key">
    Generate your API key from the [Factory Settings Page](https://app.factory.ai/settings/api-keys)
  </Step>
  
  <Step title="Prepare Your Repository">
    Ensure you have a Git repository for safe rollback and a Node.js project with JS/TS files
  </Step>
</Steps>

## Get the script

<Accordion title="View full script source">
```bash
#!/bin/bash

# Simplified Droid Import Refactoring Script
# A cookbook example of using AI to refactor imports across a codebase
#
# Usage: ./droid-refactor-imports.sh [directory]
# Example: ./droid-refactor-imports.sh src

set -e

# Configuration
CONCURRENCY=${CONCURRENCY:-5}
DRY_RUN=${DRY_RUN:-false}
TARGET_DIR="${1:-.}"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Temp files for tracking
TEMP_DIR=$(mktemp -d)
FILES_LIST="$TEMP_DIR/files.txt"
MODIFIED_COUNT=0
PROCESSED_COUNT=0

# Cleanup on exit
trap "rm -rf $TEMP_DIR" EXIT

# Function to process a single file
process_file() {
    local filepath="$1"
    local filename=$(basename "$filepath")
    
    # Check if file has imports
    if ! grep -qE "^import |^const .* = require\(|^export .* from" "$filepath" 2>/dev/null; then
        return 0
    fi
    
    echo -e "${BLUE}Processing: $filepath${NC}"
    
    # The AI prompt for refactoring imports
    local prompt="Refactor the imports in $filepath:

1. Group imports in this order with blank lines between:
   - External packages (node_modules)
   - Internal/absolute imports (@/ or src/)
   - Relative imports (./ or ../)

2. Sort alphabetically within each group
3. Remove unused imports
4. Convert require() to ES6 imports
5. Consolidate duplicate imports from same module

Only modify imports, preserve all other code exactly.
Return the complete refactored file."
    
    if [ "$DRY_RUN" = "true" ]; then
        echo -e "${YELLOW}  [DRY RUN] Would refactor imports${NC}"
        return 0
    fi
    
    # Get original file hash for comparison
    local original_hash=$(md5sum "$filepath" 2>/dev/null | cut -d' ' -f1 || md5 -q "$filepath")
    
    # Run droid to refactor the file
    if droid exec --auto low "$prompt" 2>/dev/null; then
        # Check if file was modified
        local new_hash=$(md5sum "$filepath" 2>/dev/null | cut -d' ' -f1 || md5 -q "$filepath")
        if [ "$original_hash" != "$new_hash" ]; then
            echo -e "${GREEN}  ‚úì Refactored${NC}"
            ((MODIFIED_COUNT++))
        fi
        ((PROCESSED_COUNT++))
    else
        echo "  ‚úó Failed to process"
    fi
}

# Export function and variables for parallel execution
export -f process_file
export DRY_RUN GREEN YELLOW BLUE NC

# Main execution
echo -e "${BLUE}=== Droid Import Refactoring ===${NC}"
echo -e "${BLUE}Directory: $TARGET_DIR${NC}"
echo -e "${BLUE}Concurrency: $CONCURRENCY${NC}"
[ "$DRY_RUN" = "true" ] && echo -e "${YELLOW}DRY RUN MODE${NC}"
echo ""

# Find JavaScript and TypeScript files
find "$TARGET_DIR" -type f \
    \( -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" \) \
    ! -path "*/node_modules/*" \
    ! -path "*/.git/*" \
    ! -path "*/dist/*" \
    ! -path "*/build/*" \
    > "$FILES_LIST"

FILE_COUNT=$(wc -l < "$FILES_LIST" | tr -d ' ')

if [ "$FILE_COUNT" -eq 0 ]; then
    echo -e "${YELLOW}No JavaScript/TypeScript files found${NC}"
    exit 0
fi

echo -e "${BLUE}Found $FILE_COUNT files to check${NC}\n"

# Process files in parallel
cat "$FILES_LIST" | xargs -n 1 -P "$CONCURRENCY" -I {} bash -c 'process_file "$@"' _ {}

# Show summary
echo -e "\n${BLUE}=== Summary ===${NC}"
echo -e "${GREEN}Files processed: $PROCESSED_COUNT${NC}"
[ "$DRY_RUN" = "false" ] && echo -e "${GREEN}Files modified: $MODIFIED_COUNT${NC}"

if [ "$DRY_RUN" = "false" ] && [ "$MODIFIED_COUNT" -gt 0 ]; then
    echo -e "\n${BLUE}Next steps:${NC}"
    echo "  git diff           # Review changes"
    echo "  git add -A         # Stage changes"
    echo "  git commit -m 'refactor: organize imports'"
fi
```
</Accordion>

## Basic usage

### Preview changes (dry run)

<Warning>
  Always start with a dry run to preview changes before modifying files. This helps you understand what transformations will be applied.
</Warning>

The dry run feature is controlled by the `DRY_RUN` environment variable:

```bash
# Preview what would happen (no changes made)
DRY_RUN=true ./droid-refactor-imports.sh src

# Example output:
# === Droid Import Refactoring ===
# Directory: src
# Concurrency: 5
# DRY RUN MODE
# 
# Found 25 files to check
# 
# Processing: src/components/Button.tsx
#   [DRY RUN] Would refactor imports
# Processing: src/utils/api.ts
#   [DRY RUN] Would refactor imports
```

**How dry run works:**
- When `DRY_RUN=true`: The script finds all files that need processing and shows which files have imports to refactor, but doesn't modify any files
- When `DRY_RUN=false` (default): Actually runs the AI refactoring and modifies the files

This is particularly useful for:
- Testing on a small directory first to understand the changes
- Estimating time/cost before processing a large codebase
- Verifying the script finds the right files before committing to changes

### Apply refactoring

Once you're satisfied with the preview, run the actual refactoring:

```bash
# Actually refactor the imports (default behavior)
./droid-refactor-imports.sh packages/models

# Or explicitly set DRY_RUN=false
DRY_RUN=false ./droid-refactor-imports.sh packages/models

# Adjust concurrency for faster processing
CONCURRENCY=10 ./droid-refactor-imports.sh packages/models
```

Actual execution example:
```
=== Droid Import Refactoring ===
Directory: packages/models
Concurrency: 5

Found 78 files to check

Processing: packages/models/src/organization/test-utils/fixtures.ts
Processing: packages/models/src/organization/agentReadiness/types.ts
Processing: packages/models/src/organization/utils.ts
Processing: packages/models/src/organization/agentReadiness/handlers.ts
Processing: packages/models/jest.config.ts
Processing: packages/models/src/organization/user/defaultRepositories/handlers.ts
Perfect! I've successfully refactored the imports in the file...
## Summary

I've successfully refactored the imports in `packages/models/src/organization/test-utils/fixtures.ts`. 
The imports are now properly organized with comments separating external packages from relative imports...
...
```

## Real-world transformations

### Example 1: Adding Import Groups

<Tabs>
  <Tab title="Before">
    ```typescript
    // organization/agentReadiness/types.ts
    import { FieldValue, Timestamp } from 'firebase-admin/firestore';

    export interface AgentReadinessAssessment {
      id: string;
      createdAt: Timestamp | FieldValue;
      updatedAt: Timestamp | FieldValue;
      organizationId: string;
      // ... rest of interface
    }
    ```
  </Tab>
  
  <Tab title="After">
    ```typescript
    // organization/agentReadiness/types.ts
    // External packages
    import { FieldValue, Timestamp } from 'firebase-admin/firestore';

    export interface AgentReadinessAssessment {
      id: string;
      createdAt: Timestamp | FieldValue;
      updatedAt: Timestamp | FieldValue;
      organizationId: string;
      // ... rest of interface
    }
    ```
    <Note>AI adds comment headers to clearly identify import groups</Note>
  </Tab>
</Tabs>

### Example 2: Organizing Relative Imports

<Tabs>
  <Tab title="Before">
    ```typescript
    // organization/utils.ts
    import { isEnterpriseOrg } from './subscription/utils';
    import { FirestoreOrganization } from './types';

    export function organizationHasOnboarded(
      organization: FirestoreOrganization
    ): boolean {
      return isEnterpriseOrg(organization) || organization.onboarded;
    }
    ```
  </Tab>
  
  <Tab title="After">
    ```typescript
    // organization/utils.ts
    // Relative imports
    import { isEnterpriseOrg } from './subscription/utils';
    import { FirestoreOrganization } from './types';

    export function organizationHasOnboarded(
      organization: FirestoreOrganization
    ): boolean {
      return isEnterpriseOrg(organization) || organization.onboarded;
    }
    ```
    <Note>Imports are verified to be in use and alphabetically sorted</Note>
  </Tab>
</Tabs>

### Example 3: Complex Mixed Imports

<Tabs>
  <Tab title="Before">
    ```typescript
    // test-utils/fixtures.ts
    import {
      FirestoreOrganization,
      OrganizationSettings,
    } from '../types';
    import { Timestamp } from 'firebase-admin/firestore';
    import { DEFAULT_ORGANIZATION_SETTINGS } from '../settings/constants';
    import { v4 as uuidv4 } from 'uuid';

    export function createMockOrganization(): FirestoreOrganization {
      // implementation
    }
    ```
  </Tab>
  
  <Tab title="After">
    ```typescript
    // test-utils/fixtures.ts
    // External packages
    import { Timestamp } from 'firebase-admin/firestore';
    import { v4 as uuidv4 } from 'uuid';

    // Relative imports
    import { DEFAULT_ORGANIZATION_SETTINGS } from '../settings/constants';
    import {
      FirestoreOrganization,
      OrganizationSettings,
    } from '../types';

    export function createMockOrganization(): FirestoreOrganization {
      // implementation
    }
    ```
    <Note>External packages separated from relative imports, each group sorted alphabetically</Note>
  </Tab>
</Tabs>

## Configuration reference

<ParamField path="options" type="object">
  <Expandable title="Environment Variables">
    <ParamField path="CONCURRENCY" type="number" default="5">
      Number of parallel workers for processing files. Increase for faster processing on powerful machines.
    </ParamField>
    
    <ParamField path="DRY_RUN" type="boolean" default="false">
      When set to `true`, preview changes without modifying files. Shows which files would be processed.
    </ParamField>
  </Expandable>
  
  <Expandable title="Command Line Arguments">
    <ParamField path="directory" type="string" default=".">
      The directory to process. Defaults to current directory if not specified.
    </ParamField>
  </Expandable>
</ParamField>

### What the script does

The script automatically:
1. **Finds files**: Searches for all `.js`, `.jsx`, `.ts`, and `.tsx` files
2. **Filters smartly**: Excludes `node_modules`, `.git`, `dist`, and `build` directories
3. **Checks for imports**: Only processes files that contain import statements
4. **Groups imports**: Organizes into external, internal, and relative imports
5. **Sorts alphabetically**: Within each group for consistency
6. **Removes unused**: Eliminates imports that aren't referenced
7. **Modernizes syntax**: Converts `require()` to ES6 `import`
8. **Consolidates duplicates**: Merges multiple imports from the same module

## Complete example workflow

Here's a typical workflow for refactoring imports in a large project:

```bash
#!/bin/bash
# Complete import refactoring workflow

# 1. Create a backup branch
git checkout -b backup/before-import-refactor
git checkout -

# 2. Run dry run to preview
echo "üîç Previewing changes..."
DRY_RUN=true ./droid-refactor-imports.sh src

# 3. Ask for confirmation
read -p "Proceed with refactoring? (y/n) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    exit 1
fi

# 4. Create working branch
git checkout -b feature/organize-imports

# 5. Run refactoring with higher concurrency
echo "üöÄ Starting import refactoring..."
CONCURRENCY=15 ./droid-refactor-imports.sh src

# 6. Run tests to ensure nothing broke
echo "üß™ Running tests..."
npm test

# 7. Show summary
echo "üìä Summary:"
git diff --stat
echo
echo "‚úÖ Refactoring complete! Review changes with: git diff"
```

## Handling monorepos

For monorepos with multiple packages:

```bash
# Process each package separately
for package in packages/*; do
  if [ -d "$package/src" ]; then
    echo "Processing $package..."
    ./droid-refactor-imports.sh "$package/src"
  fi
done

# Or process specific workspaces
./droid-refactor-imports.sh apps/web/src
./droid-refactor-imports.sh apps/api/src
./droid-refactor-imports.sh packages/shared/src
```


## Best practices

<Note>
  Follow these best practices for safe and effective import refactoring.
</Note>

<Steps>
  <Step title="Start with a dry run">
    Always preview changes before modifying files:
    ```bash
    # Preview what would happen without making changes
    DRY_RUN=true ./droid-refactor-imports.sh packages/models
    ```
  </Step>
  
  <Step title="Test on a small scope first">
    Start with a specific subdirectory before processing entire codebase:
    ```bash
    # Test on a single module first
    ./droid-refactor-imports.sh packages/models/src/utils
    
    # Then expand to larger directories
    ./droid-refactor-imports.sh packages/models
    ```
  </Step>
  
  <Step title="Create a git branch">
    Always work in a separate branch to isolate changes:
    ```bash
    git checkout -b refactor/organize-imports
    ./droid-refactor-imports.sh packages
    ```
  </Step>
  
  <Step title="Process incrementally">
    For large codebases, process directories separately for easier review:
    ```bash
    # Process each package separately
    ./droid-refactor-imports.sh packages/models
    git add -A && git commit -m "refactor: organize imports in models"
    
    ./droid-refactor-imports.sh packages/services  
    git add -A && git commit -m "refactor: organize imports in services"
    ```
  </Step>
  
  <Step title="Run tests after refactoring">
    Verify nothing broke after changes:
    ```bash
    npm test
    npm run typecheck
    npm run lint
    ```
  </Step>
  
  <Step title="Review changes carefully">
    Use `git diff` to review all modifications before committing:
    ```bash
    git diff --staged  # Review what will be committed
    git diff HEAD~1    # Review after committing
    ```
  </Step>
</Steps>

## Next steps

* Customize the import grouping rules for your team's conventions
* Combine with [lint and type fixing](/cli/droid-exec/cookbook/lint-typefix) for complete code cleanup
* Set up pre-commit hooks to maintain import organization
* Create project-specific configurations for different import styles

## Community examples

Share your import refactoring results on Twitter/X and tag @FactoryAI.

---
title: Skills
description: Define reusable, composable capabilities for Droids to reliably execute complex software engineering workflows.
---

Skills let you capture the way your engineering org wants work to be done and package it as reusable capabilities that Droids can invoke on demand.

# 1 · Skills overview

Skills are how you turn a general-purpose Droid into **a specialist teammate that follows your engineering playbook every time**.

Instead of re-explaining the same workflows in every prompt, you capture them once as a skill: a small, reusable bundle of **capability + context + guardrails** that Droids can invoke as part of a larger plan.

Use skills when you want the agent to:

- **Behave like your team** – follow your architecture, testing, security, and rollout norms by default.
- **Be consistent across sessions** – run the same playbook every time you ask for "frontend change" or "new service integration".
- **Scale safely** – let more people use automation without needing to be experts in the codebase or infrastructure.

## 1.1 · What is a skill?

At the file-system level, a skill is a **directory** (e.g. `.factory/skills/frontend-ui-integration/`) that contains:

- A primary spec like `SKILL.md` or `skill.mdx` with frontmatter + markdown instructions
- Optional supporting files (types, schemas, checklists) that the Droid can read when the skill is active

Conceptually, each skill defines:

- **What problem it solves** – e.g., "add a typed React surface for an existing API" or "wire a service into our event bus".
- **What inputs it expects** – feature description, services, APIs, time ranges, risk level, etc.
- **What success looks like** – required artifacts, tests, verification commands, and safety checks.

Skills are **model-invoked**: the Droid decides when to use them based on the skill description and the current task, rather than you typing a specific command.

| Scope         | Location                        | Purpose                                                                 |
| ------------- | ------------------------------- | ----------------------------------------------------------------------- |
| **Workspace** | `<repo>/.factory/skills/`       | Project skills shared with teammates; checked into git.                |
| **Personal**  | `~/.factory/skills/` (planned)  | Private skills that follow you across projects (not yet available).    |

Project skills are the primary way to share and standardize capabilities inside an engineering org.

## 1.2 · How skills differ from other configuration

Skills sit alongside other ways of shaping Droid behavior:

- **Custom droids** – define *which* model and tools to use and at what autonomy level; they are full agent configurations.
- **Custom slash commands** – are **user-invoked** macros you call explicitly (e.g., `/review-pr`); they don’t automatically trigger based on the task.
- **MCP servers** – expose external systems (APIs, databases, SaaS tools) as tools; they are about *connecting* resources, not encoding your workflow.

Skills are different because they:

- Package **how work should be done** (your engineering playbook) as reusable capabilities.
- Are **discoverable and composable** – the Droid can chain multiple skills inside a plan.
- Can sit on top of tools, custom droids, and MCP servers to orchestrate them safely.

In practice you might:

- Use MCP to expose your internal deployment API.
- Use a custom droid to define which tools/models are allowed in CI.
- Use a skill to encode "how to safely roll out a canary deployment" using that API and droid configuration.

## 1.3 · Why skills matter in enterprise codebases

Skills are especially valuable in enterprise environments where you need to:

- Standardize how Droids do **frontend implementation, service integrations, data querying, and internal tools**.
- Encode **team conventions, safety rules, and SLAs** once, then reuse them across projects.
- Make automation **discoverable, auditable, and shareable** via git, not just "whatever happened in one chat".

You can create skills from scratch for Factory, or reuse existing skills you already invested in for other agents by importing them and wiring them into your droid configuration.


# 2 · Best practices

## 2.1 Keep each skill narrow and outcome-focused

- Design skills around a **single responsibility** (e.g., "implement a typed React UI for an existing endpoint"), not "build the whole feature".
- Define a **crisp success criterion**: what artifacts should exist when the skill finishes (files changed, tests added, docs updated, approvals gathered).
- Prefer several small skills composed by a Droid over one giant "do everything" skill.

## 2.2 Make inputs explicit and structured

- Document required inputs: repo path, services involved, APIs, schemas, feature flag names, etc.
- Use **structured fields** (e.g., JSON snippets, bullet lists, tables) instead of long prose when describing APIs or data models.
- For security-sensitive workflows, include explicit **"never do"** constraints and escalation conditions.

## 2.3 Encode team conventions and guardrails

- Bake in your **testing, observability, and rollout requirements** so the skill always follows them.
- Reference your existing **AGENTS.md**, runbooks, and design docs instead of inlining everything.
- Require **proof artifacts**: tests, screenshots, log queries, or links to dashboards depending on the domain.

## 2.4 Design for enterprise constraints

- Assume **large monorepos, multiple services, and layered approvals**.
- Be explicit about **which directories** Droids may touch, which languages/frameworks are in-bounds, and which are not.
- Include guidance for **cross-team dependencies** – when to stub, when to coordinate with another team, and when to stop and ask.

## 2.5 Make skills composable

- Prefer **idempotent** skills: safe to rerun on the same branch/PR.
- Design skills to produce **machine-parseable output** where possible (e.g., a short summary block that other skills can consume).
- Keep skills **stateless** beyond the current branch: no hidden assumptions about prior runs.

## 2.6 Operate with verification and safety

- Always include a **"Verification"** section that lists commands Droids must run before completing the skill.
- Call out **fallbacks** when verification fails (rollback steps, feature flags, or canary paths).
- For production-adjacent skills, require that Droids **open PRs but never merge** without human review.


# 3 · Skills cookbook

The cookbook provides opinionated skill templates aimed at common enterprise software workflows.

We focus on four families of skills:

1. **Frontend implementation skills** – building UI surfaces that integrate with existing APIs
2. **Integration skills for complex codebases** – extending or wiring together services in large monorepos
3. **Internal data querying skills** – safe, auditable access to internal analytics or data services
4. **Internal tools skills** – building small but robust internal apps that improve developer and operator workflows

See the following examples:

- `cli/configuration/skills/frontend-ui-integration` – Frontend skill for implementing a typed UI workflow against an existing backend API
- `cli/configuration/skills/service-integration` – Skill for extending an existing service and wiring it into a complex monorepo
- `cli/configuration/skills/data-querying` – Skill for safely querying internal data services and producing shareable artifacts
- `cli/configuration/skills/internal-tools` – Skill for building or extending internal tools (admin panels, support consoles, engineering utilities)

In practice, each skill folder can also contain **supporting utilities** the agent may use alongside the core prompt template – for example:

- `SKILL.md` or `skill.mdx` – the main skill specification
- `types.ts` or `types.py` – shared types for APIs and events the skill cares about
- `schemas/` – JSON/YAML schemas or OpenAPI snippets referenced by the skill
- `checklists.md` – reusable validation or rollout checklists

These co-located files give the agent a predictable, structured bundle of context to work from when the skill is invoked.

Use these as starting points and adapt the inputs, constraints, and verification steps to match your stack and governance requirements.

name: Issue label Slack notifier

on:
  issues:
    types:
      - opened
      - labeled

jobs:
  notify:
    runs-on: ubuntu-latest
    if: |
      github.event.action == 'opened' || github.event.action == 'labeled'
    steps:
      - name: Determine Slack channel
        id: route
        uses: actions/github-script@v7
        env:
          LABEL_WEBHOOK_MAP: ${{ vars.ISSUE_LABEL_WEBHOOK_MAP }}
          DEFAULT_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          script: |
            const mapInput = (process.env.LABEL_WEBHOOK_MAP || '').trim();
            const mappings = new Map();
            if (mapInput) {
              for (const line of mapInput.split(/\r?\n/)) {
                if (!line.trim()) continue;
                const [labelName, webhookUrl] = line.split('=');
                if (labelName && webhookUrl) {
                  mappings.set(labelName.trim(), webhookUrl.trim());
                }
              }
            }

            const defaultWebhook = (process.env.DEFAULT_WEBHOOK || '').trim();
            const action = context.payload.action;
            const issueLabels = (context.payload.issue.labels || []).map(label => label.name).filter(Boolean);
            const candidates = [];

            if (action === 'labeled' && context.payload.label?.name) {
              candidates.push(context.payload.label.name);
            }

            for (const name of issueLabels) {
              if (!candidates.includes(name)) {
                candidates.push(name);
              }
            }

            if (candidates.length === 0) {
              core.setFailed('No labels available to determine Slack webhook.');
              return;
            }

            let webhook;
            let matchedLabel;
            for (const candidate of candidates) {
              if (mappings.has(candidate)) {
                webhook = mappings.get(candidate);
                matchedLabel = candidate;
                break;
              }
            }

            if (!webhook) {
              webhook = defaultWebhook;
              matchedLabel = candidates[0];
            }

            if (!webhook) {
              core.setFailed('No Slack webhook matched and no default webhook provided.');
              return;
            }

            core.setOutput('webhook', webhook);
            core.setOutput('label', matchedLabel);
            const issueBody = (context.payload.issue.body || '').trim();
            let summary = issueBody;
            if (summary) {
              summary = summary.replace(/\r\n/g, '\n');
              summary = summary.replace(/\n{3,}/g, '\n\n');
              if (summary.length > 400) {
                summary = summary.slice(0, 400).trimEnd() + 'â€¦';
              }
            }
            core.setOutput('summary', summary);

      - name: Add ðŸ‘€ reaction
        if: github.event.action == 'labeled'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              content: 'eyes'
            });

      - name: Send Slack notification
        env:
          WEBHOOK_URL: ${{ steps.route.outputs.webhook }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_SUMMARY: ${{ steps.route.outputs.summary }}
        run: |
          if [ -z "${WEBHOOK_URL}" ]; then
            echo "Slack webhook URL not provided." >&2
            exit 1
          fi

          if ! command -v jq >/dev/null 2>&1; then
            echo "jq is required but not available" >&2
            exit 1
          fi

          payload=$(jq -n --arg url "$ISSUE_URL" --arg title "$ISSUE_TITLE" --arg summary "$ISSUE_SUMMARY" '{
            text: $url,
            unfurl_links: true,
            unfurl_media: false,
            blocks: (
              if ($summary | length) > 0 then
                [
                  {
                    type: "section",
                    text: {
                      type: "mrkdwn",
                      text: "<\($url)|\($title)>"
                    }
                  },
                  {
                    type: "section",
                    text: {
                      type: "mrkdwn",
                      text: $summary
                    }
                  }
                ]
              else
                [
                  {
                    type: "section",
                    text: {
                      type: "mrkdwn",
                      text: "<\($url)|\($title)>"
                    }
                  }
                ]
              end
            )
          }')

          curl -X POST -H 'Content-type: application/json' --data "$payload" "$WEBHOOK_URL"
